<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Find the Slope!</title>
<style>
  :root {
    --bg-main: #060812;
    --bg-panel: #101521;
    --grid: #272c3b;
    --grid-soft: #171b28;
    --axis: #f5f5f5;
    --text-main: #f5f5ff;
    --text-muted: #9aa0ba;
  }

  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body {
    background: radial-gradient(circle at top left, #1b203a 0, #050611 60%);
    font-family: courier new;
    color: var(--text-main);
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
    justify-content: center;
    align-items: center;
  }

  h1 {
    margin-bottom: 8px;
    font-size: 1.8rem;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    color: #f5f5ff;
    text-shadow: 0 0 12px rgba(255,255,255,0.05);
  }

  #score {
    margin-bottom: 14px;
    font-size: 1rem;
    color: var(--text-muted);
  }

  .canvas-wrapper {
    width: min(80vmin, 85vh);
    aspect-ratio: 1/1;
    position: relative;
    background: radial-gradient(circle at center, #151a28 0, #050711 80%);
    border-radius: 5px;
    border: 1px solid rgba(255,255,255,0.1);
    overflow: hidden;
    box-shadow:
      inset 0 0 25px rgba(0,0,0,0.7),
      0 20px 40px rgba(0,0,0,0.8);
  }

  #graphCanvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  .input-bar {
    position: fixed;
    bottom: 5px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(10,15,25,0.9);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 4px;
    padding: 1px 18px;
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 1.1rem;
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    backdrop-filter: blur(8px);
  }

  .input-bar span {
    color: var(--text-muted);
  }

  #exprInput {
    border: none;
    background: transparent;
    outline: none;
    color: #fff;
    font-size: 1.1rem;
    width: 120px;
    text-align: center;
	font-family: Courier New, monospace;
  }

  #exprInput::placeholder {
    color: rgba(150,150,170,0.5);
  }

  canvas#confettiCanvas {
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%);
    pointer-events: none;
    width: 100vw;
    height: 100vh;
  }
</style>
</head>
<body>

<h1>Hitta linjens funktion</h1>
<div id="score">Score: 0</div>

<div class="canvas-wrapper">
  <canvas id="graphCanvas"></canvas>
</div>

<canvas id="confettiCanvas"></canvas>

<div class="input-bar">
  <span>y =</span>
  <input id="exprInput" type="text" placeholder="" autocomplete="off" spellcheck="false">
</div>

<script>
/* -------------------
    GLOBAL VARIABLES
--------------------*/
const canvas = document.getElementById("graphCanvas");
const ctx = canvas.getContext("2d");
let W, H;

const X_MIN = -10, X_MAX = 10;
const Y_MIN = -10, Y_MAX = 10;

let target = null;
let guess = null;

let score = 0;

const exprInput = document.getElementById("exprInput");
const scoreEl = document.getElementById("score");

const confettiCanvas = document.getElementById("confettiCanvas");
const confettiCtx = confettiCanvas.getContext("2d");

/* -------------------
   RESIZE HANDLING
--------------------*/
function resize() {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;

  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  W = rect.width;
  H = rect.height;

  confettiCanvas.width = window.innerWidth;
  confettiCanvas.height = window.innerHeight;
}
window.addEventListener("resize", () => {
  resize();
  draw();
});

/* -------------------
     GRID DRAWING
--------------------*/
function xToPx(x) {
  return (x - X_MIN) / (X_MAX - X_MIN) * W;
}
function yToPx(y) {
  return H - (y - Y_MIN) / (Y_MAX - Y_MIN) * H;
}

function drawGrid() {
  if (!W || !H) return;

  ctx.clearRect(0,0,W,H);

  // background
  const g = ctx.createLinearGradient(0,0,W,H);
  g.addColorStop(0,"#080a14");
  g.addColorStop(1,"#050711");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // gridlines
  ctx.lineWidth = 1;

  for (let x=Math.ceil(X_MIN); x<=X_MAX; x++) {
    const px = xToPx(x);
    ctx.strokeStyle =
      x===0 ? "rgba(245,245,245,0.9)" :
      x%5===0 ? "#272c3b" : "#171b28";

    ctx.beginPath();
    ctx.moveTo(px,0);
    ctx.lineTo(px,H);
    ctx.stroke();
  }

  for (let y=Math.ceil(Y_MIN); y<=Y_MAX; y++) {
    const py = yToPx(y);
    ctx.strokeStyle =
      y===0 ? "rgba(245,245,245,0.9)" :
      y%5===0 ? "#272c3b" : "#171b28";

    ctx.beginPath();
    ctx.moveTo(0,py);
    ctx.lineTo(W,py);
    ctx.stroke();
  }

  // tiny axis numbers
  const ox = xToPx(0);
  const oy = yToPx(0);
  ctx.fillStyle = "#7f8499";
  ctx.font = "9px system-ui";

  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  for (let x=-10; x<=10; x++) {
    if (x===0) continue;
    const px = xToPx(x);
    ctx.fillText(x, px, oy+4);
  }

  ctx.textAlign = "right";
  ctx.textBaseline = "middle";
  for (let y=-10; y<=10; y++) {
    if (y===0) continue;
    const py = yToPx(y);
    ctx.fillText(y, ox-4, py);
  }

  // origin dot
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(ox,oy,2,0,Math.PI*2);
  ctx.fill();
}

/* -------------------
     LINE DRAWING
--------------------*/
function drawLine(m, b, color, width=2) {
  const x1 = X_MIN, x2 = X_MAX;
  const y1 = m*x1 + b;
  const y2 = m*x2 + b;

  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.beginPath();
  ctx.moveTo(xToPx(x1), yToPx(y1));
  ctx.lineTo(xToPx(x2), yToPx(y2));
  ctx.stroke();
}

/* -------------------
   EXPRESSION PARSER
--------------------*/
function parseExpression(expr) {
  let s = expr.replace(/\s+/g,"");
  if (!s) return null;

  if (!s.includes("x")) {
    // constant function
    const b = parseFloat(s);
    if (isNaN(b)) return null;
    return {m:0, b};
  }

  const xPos = s.indexOf("x");
  let left = s.slice(0, xPos);
  let right = s.slice(xPos+1);

  let m;
  if (left === "" || left === "+") m = 1;
  else if (left === "-") m = -1;
  else {
    m = parseFloat(left);
    if (isNaN(m)) return null;
  }

  let b = 0;
  if (right) {
    b = parseFloat(right);
    if (isNaN(b)) return null;
  }

  return {m, b};
}

/* -------------------
    GAME LOGIC
--------------------*/
function randomLine() {
  let m = 0;
  while (m === 0) { // ensure actual slope
    m = Math.floor(Math.random()*7)-3; // -3..3
  }
  const b = Math.floor(Math.random()*11)-5; // -6..6
  return {m, b};
}

function newRound() {
  target = randomLine();
  guess = null;
  exprInput.value = "";
  draw();
}

function checkMatch() {
  if (!guess) return false;
  return Math.abs(guess.m - target.m) < 0.0001 &&
         Math.abs(guess.b - target.b) < 0.0001;
}

/* -------------------
      CONFETTI
--------------------*/
let confettiPieces = [];
let confettiStart = 0;
const CONF_DURATION = 8000;

function spawnConfetti() {
  const tier = Math.floor(score/10);
  const count = 60 + tier*40;

  confettiPieces = [];

  for (let i=0; i<count; i++) {
    confettiPieces.push({
      x: Math.random()*window.innerWidth,
      y: Math.random()*-200,
      vx: (Math.random()-0.5)*2*(1+tier*0.3),
      vy: 2 + Math.random()*3*(1+tier*0.4),
      size: 4 + Math.random()*6,
      rot: Math.random()*Math.PI*2,
      vr: (Math.random()-0.5)*0.2
    });
  }
  confettiStart = performance.now();
  requestAnimationFrame(updateConfetti);
}

function updateConfetti(t) {
  const elapsed = t - confettiStart;
  confettiCtx.clearRect(0,0,window.innerWidth,window.innerHeight);

  confettiPieces.forEach(p=>{
    p.x += p.vx;
    p.y += p.vy;
    p.rot += p.vr;

    confettiCtx.save();
    confettiCtx.translate(p.x,p.y);
    confettiCtx.rotate(p.rot);
    confettiCtx.fillStyle = `hsl(${Math.random()*360},80%,60%)`;
    confettiCtx.fillRect(-p.size/2,-p.size/2,p.size,p.size);
    confettiCtx.restore();
  });

  if (elapsed < CONF_DURATION) {
    requestAnimationFrame(updateConfetti);
  }
}

/* -------------------
        DRAW
--------------------*/
function draw() {
  drawGrid();

  // if target not ready yet, just show grid
  if (!target) return;

  // target line
  drawLine(target.m, target.b, "rgba(56,189,248,0.9)", 3);

  // guess line
  if (guess) {
    drawLine(guess.m, guess.b, "rgba(251,191,36,0.9)", 2.2);
  }
}

/* -------------------
     INPUT EVENTS
--------------------*/
exprInput.addEventListener("input", ()=>{
  const expr = exprInput.value;
  guess = parseExpression(expr);

  draw();

  if (guess && checkMatch()) {
    score++;
    scoreEl.textContent = "Score: " + score;
    spawnConfetti();
    setTimeout(newRound, 3000);
  }
});

/* -------------------
      START GAME
--------------------*/
window.addEventListener("load", () => {
  resize();
  newRound(); // newRound() will call draw()
});
</script>
</body>
</html>


