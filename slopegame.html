<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Find the Slope!</title>
<style>
  :root {
    /* Gradient + panel theme from your other game */
    --grad1: #feac5e;
    --grad2: #c779d0;
    --grad3: #4bc0c8;
    --bg: linear-gradient(135deg, var(--grad1), var(--grad2) 45%, var(--grad3) 100%);
    --front-bg: linear-gradient(145deg, #5e548e 0%, #231942 70%, #0e0a1f 100%);
    --back-bg: linear-gradient(145deg, #0a3a4a 0%, #0a2232 70%, #02141a 100%);
    --text: #fffaf7;
    --muted: #e6e6e6cc;
    --border: #ffffff;

    /* Map old variables to new palette */
    --bg-main: var(--bg);
    --bg-panel: var(--front-bg);
    --text-main: var(--text);
    --text-muted: var(--muted);
    --axis: #ffffff;
    --grid: rgba(255,255,255,0.18);
    --grid-soft: rgba(255,255,255,0.08);
  }

  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  html, body {
    height: 100%;
  }

  body {
    background: var(--bg-main);
    font-family: Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    color: var(--text-main);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    justify-content: center;
    align-items: center;
    text-align: center;
  }

  h1 {
    
    padding-bottom:20px;
    font-size: 26px;
    font-weight: 800;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--text-main);
    text-shadow:
      0 8px 12px rgba(0, 20, 40, 0.7),
      0 5px 2px rgba(0, 0, 0, 0.6);
  }

  /* Bottom-left score */
  #score {
    position: fixed;
    left: 16px;
    bottom: 12px;
    font-family: "Roboto, Inter, system-ui, -apple-system, Courier New", monospace;
    font-size: 1.8rem;
    color: white;
    padding: 4px 8px;
    z-index: 1000;
    text-align: left;
	    text-shadow:
      0 3px 7px rgba(0, 20, 40, 0.7),
      0 3px 2px rgba(0, 0, 0, 0.6);
	  
	   background: rgba(10, 10, 30, 0.4);        /* translucent dark */
  border: 1px solid rgba(255, 255, 255, 0.35);
  border-radius: 6px;                      /* pill shape */
  box-shadow:
    0 8px 18px rgba(0, 0, 0, 0.55),
    0 0 10px rgba(255, 255, 255, 0.08);
  backdrop-filter: blur(6px);                /* glassy effect (if supported) */
  }

  /* Bottom-right streak */
  #streak {
    position: fixed;
    right: 16px;
    bottom: 12px;
    font-family: "Roboto, Inter, system-ui, -apple-system, Courier New", monospace;
	
    font-size: 1.8rem;
    color: white;
    padding: 4px 8px;
    z-index: 1000;
    text-align: right;
	    text-shadow:
      0 3px 7px rgba(0, 20, 40, 0.7),
      0 3px 2px rgba(0, 0, 0, 0.6);
	  
	  	   background: rgba(10, 10, 30, 0.4);        /* translucent dark */
  border: 1px solid rgba(255, 255, 255, 0.35);
  border-radius: 6px;                      /* pill shape */
  box-shadow:
    0 8px 18px rgba(0, 0, 0, 0.55),
    0 0 10px rgba(255, 255, 255, 0.08);
  backdrop-filter: blur(6px);                /* glassy effect (if supported) */
  }

  .game-shell {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 18px;
    padding: 0 12px;
    width: 100%;
    max-width: 1200px;
  }

  .side-panel {
    width: 210px;
    max-width: 230px;
    
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,1);
    padding: 12px 14px;
    box-shadow:
      0 20px 40px rgba(0,0,0,0.45),
      inset 0 1px 0 rgba(255,255,255,0.08);
    font-size: 0.75rem;
    color: var(--text-muted);
    line-height: 1.4;
    text-align: left;
	
			  	   background: rgba(10, 10, 30, 0.5);        /* translucent dark */

  border-radius: 6px;                      /* pill shape */

  backdrop-filter: blur(6px);                /* glassy effect (if supported) */
  }

  .side-panel h2 {
    font-size: 0.95rem;
    margin-bottom: 4px;
    color: var(--text-main);
    font-weight: 700;
  }

  .side-panel ul {
    padding-left: 18px;
    margin-top: 4px;
  }

  .side-panel li {
    margin-bottom: 3px;
  }

  .canvas-wrapper {
    width: min(85vmin, 85vh);
    aspect-ratio: 1/1;
    position: relative;
    background: var(--back-bg);
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,1);
    overflow: hidden;
    box-shadow:
      0 20px 40px rgba(0,0,0,0.6),
      inset 0 0 18px rgba(0,0,0,0.7);
  }

  #graphCanvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  .function-panel {
    width: 220px;
    max-width: 230px;
    background: rgba(255,255,255,0.0);
    border-radius:4px;
    border: 0px solid rgba(255,255,255,0.4);
    padding: 12px 14px;

    display: flex;
    flex-direction: column;
    gap: 8px;
    text-align: left;
  }

  .function-panel-title {
    font-size: 0.9rem;
    color: white;
    font-weight: 500;
    box-shadow:
      0 20px 40px rgba(255,0,0,1),
      inset 0 1px 0 rgba(255,255,255,1);
  }

  .function-display {
    display: flex;
    align-items: baseline;
    margin-bottom: -4px;
    gap: 6px;
    font-size: 1.5rem;
    border-radius: 0px;
    font-family: "Roboto, Inter, system-ui, -apple-system, Courier New", monospace; 
    font-weight:800;
		    text-shadow:
      0 3px 7px rgba(0, 20, 40, 0.7),
      0 3px 3px rgba(0, 0, 0, 0.6);
	
    border: 1px solid rgba(255,255,255,0.45);
	
		  	   background: rgba(10, 10, 30, 0.4);        /* translucent dark */
  border: 1px solid rgba(255, 255, 255, 0.8);
  border-radius: 6px;                      /* pill shape */
  box-shadow:-2
    0 8px 18px rgba(0, 0, 0, 0.55),
    0 0 10px rgba(255, 255, 255, 0.08);
  backdrop-filter: blur(6px);                /* glassy effect (if supported) */
  
  padding-left:15px;
  padding-top:3px;
  padding-bottom:9px;
  }

  .function-display span {
    color: var(--text);
    font-weight: 600;
  }

  #exprInput {
    border: none;
    background: transparent;
    outline: none;
    color: #fffaf7;
    font-size: 1.5rem;
    width: 90px;
    text-align: left;
    font-family: "Roboto, Inter, system-ui, -apple-system, Courier New", monospace; 
    font-weight:800;
			    text-shadow:
      0 3px 7px rgba(0, 20, 40, 0.7),
      0 3px 3px rgba(0, 0, 0, 0.6);
    border-bottom: 0px dashed rgba(255,255,255,0.4);
    padding-bottom: 0px;
  }

  #exprInput::placeholder {
    color: rgba(240,230,255,0.6);
  }

  .hint {
    font-size: 0.78rem;
    color: var(--text-muted);
    opacity: 0.95;
  }

  canvas#confettiCanvas {
    position: fixed;
    left: 0;
    top: 0;
    pointer-events: none;
    width: 100vw;
    height: 100vh;
    z-index: 500;
  }

  @media (max-width: 900px) {
    .game-shell {
      flex-direction: column;
      gap: 10px;
    }
    .side-panel,
    .function-panel {
      width: 90%;
      max-width: 340px;
    }
    .canvas-wrapper {
      width: min(80vmin, 55vh);
    }
  }
</style>
</head>
<body>

<h1>Hitta linjens funktion</h1>

<div class="game-shell">
  <!-- Left instructions -->
  <div class="side-panel">
    <h2>Instruktioner</h2>
    <ul>
      <li>Titta på den <b>röda linjen</b>.</li>
      <li>Skriv dess funktion i rutan till höger.</li>
      <li>Använd formen <br>y = kx + m, t.ex. 2x+3</li>
      <li>"k" är lutningen på linjen. "m" är var den skär y-axeln</li>
      <li>För att få poäng måste funktionen vara helt rätt.</li>
      <li><b>Streak</b> bryts om du gissar fel lutning eller fel m-värde.</li>
      <li><b><i>Försök att nå en streak på 10!</i></b></li>
    </ul>
  </div>

  <!-- Center graph -->
  <div class="canvas-wrapper">
    <canvas id="graphCanvas"></canvas>
  </div>

  <!-- Right function input -->
  <div class="function-panel">
    <div class="function-display">
      <span>y =&nbsp;</span>
      <input id="exprInput" type="text" placeholder="" autocomplete="off" spellcheck="false">
    </div>
  </div>
</div>

<!-- Separate floating stats -->
<div id="score">Score: 0</div>
<div id="streak">Streak: 0</div>

<canvas id="confettiCanvas"></canvas>

<script>
/* -------------------
    GLOBAL VARIABLES
--------------------*/
const canvas = document.getElementById("graphCanvas");
const ctx = canvas.getContext("2d");
let W, H;

const X_MIN = -10, X_MAX = 10;
const Y_MIN = -10, Y_MAX = 10;

let target = null;
let guess = null;

let score = 0;
let streak = 0;
let roundSolved = false; // prevent scoring twice for same round

const exprInput = document.getElementById("exprInput");
const scoreEl = document.getElementById("score");
const streakEl = document.getElementById("streak");

const confettiCanvas = document.getElementById("confettiCanvas");
const confettiCtx = confettiCanvas.getContext("2d");

/* -------------------
   RESIZE HANDLING
--------------------*/
function resize() {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;

  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  W = rect.width;
  H = rect.height;

  confettiCanvas.width = window.innerWidth;
  confettiCanvas.height = window.innerHeight;
}
window.addEventListener("resize", () => {
  resize();
  draw();
});

/* -------------------
   SCORE / STREAK UI
--------------------*/
function updateScoreText() {
  scoreEl.textContent = `Score: ${score}`;
  streakEl.textContent = `Streak: ${streak}`;
}

/* -------------------
     GRID DRAWING
--------------------*/
function xToPx(x) {
  return (x - X_MIN) / (X_MAX - X_MIN) * W;
}
function yToPx(y) {
  return H - (y - Y_MIN) / (Y_MAX - Y_MIN) * H;
}

function drawGrid() {
  if (!W || !H) return;

  ctx.clearRect(0,0,W,H);

  // Use darker version of back-bg for canvas interior
  const g = ctx.createLinearGradient(0,0,W,H);
  g.addColorStop(0, "#050815");
  g.addColorStop(1, "#020611");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  ctx.lineWidth = 1;

  for (let x=Math.ceil(X_MIN); x<=X_MAX; x++) {
    const px = xToPx(x);
    ctx.strokeStyle =
      x===0 ? "rgba(255,255,255,0.95)" :
      x%5===0 ? "rgba(255,255,255,0.22)" : "rgba(255,255,255,0.09)";

    ctx.beginPath();
    ctx.moveTo(px,0);
    ctx.lineTo(px,H);
    ctx.stroke();
  }

  for (let y=Math.ceil(Y_MIN); y<=Y_MAX; y++) {
    const py = yToPx(y);
    ctx.strokeStyle =
      y===0 ? "rgba(255,255,255,0.95)" :
      y%5===0 ? "rgba(255,255,255,0.22)" : "rgba(255,255,255,0.09)";

    ctx.beginPath();
    ctx.moveTo(0,py);
    ctx.lineTo(W,py);
    ctx.stroke();
  }

  const ox = xToPx(0);
  const oy = yToPx(0);
  ctx.fillStyle = "rgba(255,250,247,0.9)";
  ctx.font = "12px system-ui";

  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  for (let x=-10; x<=10; x++) {
    if (x===0) continue;
    const px = xToPx(x);
    ctx.fillText(x, px, oy+4);
  }

  ctx.textAlign = "right";
  ctx.textBaseline = "middle";
  for (let y=-10; y<=10; y++) {
    if (y===0) continue;
    const py = yToPx(y);
    ctx.fillText(y, ox-4, py);
  }

  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.arc(ox,oy,2,0,Math.PI*2);
  ctx.fill();
}

/* -------------------
     LINE DRAWING
--------------------*/
function drawLine(m, b, color, width=2) {
  const x1 = X_MIN, x2 = X_MAX;
  const y1 = m*x1 + b;
  const y2 = m*x2 + b;

  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.beginPath();
  ctx.moveTo(xToPx(x1), yToPx(y1));
  ctx.lineTo(xToPx(x2), yToPx(y2));
  ctx.stroke();
}

/* -------------------
   EXPRESSION PARSER
--------------------*/
function parseExpression(expr) {
  let s = expr.replace(/\s+/g,"");
  if (!s) return null;

  if (!s.includes("x")) {
    const b = parseFloat(s);
    if (isNaN(b)) return null;
    return {m:0, b};
  }

  const xPos = s.indexOf("x");
  let left = s.slice(0, xPos);
  let right = s.slice(xPos+1);

  let m;
  if (left === "" || left === "+") m = 1;
  else if (left === "-") m = -1;
  else {
    m = parseFloat(left);
    if (isNaN(m)) return null;
  }

  let b = 0;
  if (right) {
    b = parseFloat(right);
    if (isNaN(b)) return null;
  }

  return {m, b};
}

/* -------------------
    GAME LOGIC
--------------------*/
function randomLine() {
  let m = 0;
  while (m === 0) { // ensure actual slope
    m = Math.floor(Math.random()*7)-3; // -3..3
  }
  const b = Math.floor(Math.random()*11)-5; // -5..5
  return {m, b};
}

function newRound() {
  target = randomLine();
  guess = null;
  exprInput.value = "";
  roundSolved = false;
  draw();
}

/* -------------------
   ARCADE EXPLOSION SOUND
--------------------*/
function playExplosionSound() {

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  /* --- WHITE NOISE EXPLOSION (main boom) --- */
  const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.4, audioCtx.sampleRate);
  const noiseData = noiseBuffer.getChannelData(0);
  for (let i = 0; i < noiseData.length; i++) {
    noiseData[i] = Math.random() * 2 - 1;
  }

  const noise = audioCtx.createBufferSource();
  noise.buffer = noiseBuffer;

  // Filter sweep for KRRRSH effect
  const noiseFilter = audioCtx.createBiquadFilter();
  noiseFilter.type = "lowpass";
  noiseFilter.frequency.setValueAtTime(3000, audioCtx.currentTime);
  noiseFilter.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.35);

  const noiseGain = audioCtx.createGain();
  noiseGain.gain.setValueAtTime(0.4, audioCtx.currentTime);
  noiseGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.35);

  noise.connect(noiseFilter);
  noiseFilter.connect(noiseGain);
  noiseGain.connect(audioCtx.destination);


  /* --- BASS THUMP (old-school boom) --- */
  const osc = audioCtx.createOscillator();
  const bassGain = audioCtx.createGain();

  osc.type = "triangle";
  osc.frequency.setValueAtTime(120, audioCtx.currentTime);       // start pitch
  osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.3);  // drop pitch = boom

  bassGain.gain.setValueAtTime(0.1, audioCtx.currentTime);
  bassGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

  osc.connect(bassGain);
  bassGain.connect(audioCtx.destination);


  /* --- START --- */
  noise.start();
  noise.stop(audioCtx.currentTime + 0.4);

  osc.start();
  osc.stop(audioCtx.currentTime + 0.31);
}

/* -------------------
   FAIL SOUND (dun–DON)
--------------------*/
function playFailSound() {
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // First "dun"
  const osc1 = audioCtx.createOscillator();
  const gain1 = audioCtx.createGain();
  osc1.type = "triangle";
  osc1.frequency.setValueAtTime(140, audioCtx.currentTime);
  gain1.gain.setValueAtTime(0.1, audioCtx.currentTime);
  gain1.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.18);

  // Second "DON"
  const osc2 = audioCtx.createOscillator();
  const gain2 = audioCtx.createGain();
  osc2.type = "square";
  osc2.frequency.setValueAtTime(95, audioCtx.currentTime + 0.15);
  gain2.gain.setValueAtTime(0.001, audioCtx.currentTime);
  gain2.gain.setValueAtTime(0.1, audioCtx.currentTime + 0.15);
  gain2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.32);

  osc1.connect(gain1);
  gain1.connect(audioCtx.destination);

  osc2.connect(gain2);
  gain2.connect(audioCtx.destination);

  osc1.start();
  osc1.stop(audioCtx.currentTime + 0.20);

  osc2.start(audioCtx.currentTime + 0.15);
  osc2.stop(audioCtx.currentTime + 0.33);
}

/* -------------------
      FIREWORKS
--------------------*/
let fireworks = [];
let fireworksStart = 0;
const FIREWORK_DURATION = 600; // ms

function getOriginScreenPosition() {
  const rect = canvas.getBoundingClientRect();
  const ox = xToPx(0);
  const oy = yToPx(0);
  return {
    x: rect.left + ox,
    y: rect.top + oy
  };
}

function spawnFireworks() {
  const origin = getOriginScreenPosition();
  const count = 90;

  fireworks = [];
  const baseHue = Math.random() * 360;

  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const maxDist = 150 + Math.random() * 250; // treat as max radius
    const hue = baseHue + (Math.random() * 60 - 30);
    fireworks.push({
      x0: origin.x,
      y0: origin.y,
      angle,
      maxDist,
      color: `hsl(${hue}, 90%, 60%)`
    });
  }

  fireworksStart = performance.now();
  requestAnimationFrame(updateFireworks);
}

function updateFireworks(t) {
  const elapsed = t - fireworksStart;
  const progress = Math.min(1, elapsed / FIREWORK_DURATION);

  confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

  // easeOutQuad: fast at start, slows near end
  fireworks.forEach(p => {
    const eased = 1 - (1 - progress) * (1 - progress);
    const dist = p.maxDist * eased;

    const x = p.x0 + Math.cos(p.angle) * dist;
    const y = p.y0 + Math.sin(p.angle) * dist;

    const alpha = Math.max(0, 1 - progress);
    confettiCtx.fillStyle = p.color
      .replace("hsl", "hsla")
      .replace(")", `, ${alpha})`);
    confettiCtx.beginPath();
    confettiCtx.arc(x, y, 3, 0, Math.PI * 2);
    confettiCtx.fill();
  });

  if (elapsed < FIREWORK_DURATION) {
    requestAnimationFrame(updateFireworks);
  } else {
    confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
  }
}

/* -------------------
        DRAW
--------------------*/
function draw() {
  drawGrid();
  if (!target) return;

  // target line (soft pinkish-red)
  drawLine(target.m, target.b, "rgba(255,50,50,1)", 1.4);

  // guess line (turquoise)
  if (guess) {
    drawLine(guess.m, guess.b, "rgba(75,192,200,1)", 1.4);
  }
}

/* -------------------
     INPUT EVENTS
--------------------*/
exprInput.addEventListener("input", () => {
  if (!target || roundSolved) return;

  const raw = exprInput.value;
  const s = raw.replace(/\s+/g,"");

  // don't judge anything until there's an "x"
  if (!s.includes("x")) {
    guess = null;
    draw();
    return;
  }

  const parsed = parseExpression(raw);
  guess = parsed;
  draw();

  if (!parsed) return;

  const xPos = s.indexOf("x");
  const afterX = xPos >= 0 ? s.slice(xPos + 1) : "";
  const hasExplicitB = /[+\-]/.test(afterX);

  const mCorrect = parsed.m === target.m;
  const bCorrect = parsed.b === target.b;

  // Wrong slope -> immediate streak reset
  if (!mCorrect) {
    streak = 0;
    updateScoreText();
    playFailSound();
    return;
  }

  // Slope correct
  if (target.b === 0) {
    if (bCorrect) {
      roundSolved = true;
      score++;
      streak++;
      updateScoreText();
      playExplosionSound();
      spawnFireworks();
      setTimeout(newRound, 600);
    } else {
      streak = 0;
      updateScoreText();
      playFailSound();
    }
  } else {
    // target b != 0
    // Require explicit + or - after x for non-zero b (so "2x5" is not accepted)
    if (!hasExplicitB) {
      return;
    }

    if (bCorrect) {
      roundSolved = true;
      score++;
      streak++;
      updateScoreText();
      playExplosionSound();
      spawnFireworks();
      setTimeout(newRound, 600);
    } else {
      streak = 0;
      updateScoreText();
      playFailSound();
    }
  }
});

/* -------------------
      START GAME
--------------------*/
window.addEventListener("load", () => {
  resize();
  updateScoreText();
  newRound();
  setTimeout(() => {
    exprInput.focus();
  }, 50);
});
</script>
</body>
</html>
